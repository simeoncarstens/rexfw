##!/c5/shared/Python/2.7.3-shared/bin/python -u
import numpy
from csb.statistics.samplers import State, EnsembleState
from ox.structure import get_coords
from protlib import *
from copy import deepcopy
import sys, os
from cPickle import dump, load
from mpsampling import MPAlternatingAdjacentSwapScheme, MPHMCSampler
from langevin import *

path = '~'
target = get_coords(path + '/pdb/1UBQ.pdb',atoms=['CA'])[:-3]
pdbfile = path + '/pdbfiles/1ubq_protonated_whatif_iupac.pdb'
datafile = path + '/data/ubq/nonredundant.xml'

posti = create_posterior(pdbfile=pdbfile, datafile=datafile)
# posti = load(open('/tmp/test.pcikel'))
pdf = ISDWrapper(1.0, 1.0, posti)

traj_length = int(sys.argv[1])
it = sys.argv[2]

outdir = "/Bis/Scratch2/carstens/simulation_results/ubq/langevinrens/"
os.system("mkdir "+outdir+str(traj_length))
os.system("mkdir "+outdir+str(traj_length)+"/"+it)
outpath = outdir+str(traj_length)+"/"+it+"/"
statsfile = outpath + "stats.txt"
paccfile = outpath + "pacc.txt"
statesfile = outpath + "ensemble.pickle"
worksfile = outpath + "works.pickle"
timestepsfile = outpath + "timesteps.pickle"

timesteps = numpy.array(timesteps[::3])
lambda_values = lambda_values[::3]
q_values = q_values[::3]
states = states[::3]

# Set parameters for HMC equilibrium sampling
eq_hmc_traj_length = 25
eq_hmc_timesteps = timesteps

# Initialize HMC samplers:
s_pdfs = [deepcopy(pdf) for i in range(len(timesteps))]
for i in range(len(s_pdfs)):
    s_pdfs[i].l = lambda_values[i]
    s_pdfs[i].q = q_values[i]

samplers = [MPHMCSampler(s_pdfs[i], State(states[i].position), s_pdfs[i].gradient, eq_hmc_timesteps[i],
            eq_hmc_traj_length) for i in range(len(s_pdfs))]

#### RENS parameters ####
rens_traj_length = traj_length
im_pdfs = [LambdaISDWrapper((lambda_values[i], q_values[i]), (lambda_values[i+1], q_values[i+1]), posti) 
           for i in range(len(lambda_values) - 1)]

params = [LTMDRENSSwapParameterInfo(samplers[i], samplers[i+1], timestep=timesteps[i+1] / 5.0, 
                                    gradient=im_pdfs[i].gradient, traj_length=rens_traj_length, gamma=0.01) 
                                    for i in range(len(lambda_values) - 1)]
for i, p in enumerate(params):
    p.index = i
    
# Initialize Langevin-RENS algorithm:
algorithm = MPLTMDRENS(samplers, params, n_processes=7)

# Initialize swapping scheme:
swapper = MPAlternatingAdjacentSwapScheme(algorithm)

# Initialize statistics class
stats = ProteinStatistics(algorithm, pdbfile, posti, statsfile)

# Initialize empty list which will store the samples:
states = []
nsamples = 15001

def dump_works(path):
    from cPickle import dump
    
    op = open(path, "w")
    dump(algorithm.works2, op, 2)
    op.close()

def dump_timesteps(path):
    from cPickle import dump
    
    op = open(path, "w")
    dump([x.timestep for x in algorithm._samplers], op, 2)
    op.close()

for s in samplers: s.mpinit()

for i in range(nsamples + 1):
    if i % 5 == 0 and i > 0:
        swapper.swap_all()
	if i > 0:	
	    print "############# MC step #"+str(i)+" ###############"
	    print "HMC acceptance rates:", ["%.2f" % x.acceptance_rate for x in samplers]
	    print "NHRENS acceptance rates:", ["%.2f" % x for x in algorithm.acceptance_rates]
	    print
    else:
        algorithm.sample()

    states.append([x.clone() for x in algorithm.state])
    if i % 5 == 0 and i > 0:
        output = open(paccfile, "a")
        outputstr = str(i) + "\t"
        outputstrlist = [str(x) + "\t" for x in algorithm.acceptance_rates]
        for x in outputstrlist: outputstr += x
        outputstr += "\n"
        output.write(outputstr)
        output.close()
        
    if i % 15 == 0 and i > 0:
        stats.dumpStats(i)     

    if i % 50 == 0 and i > 0:
        dump_works(worksfile)
        
    if i % 250 == 0 and i > 0:
        output = open(statesfile, "w")
        dump(states, output, 2)
        output.close()

        dump_timesteps(timestepsfile)

    if i > 1:
        for s in samplers:
            if s.last_move_accepted:
                s.timestep *= 1.05
            else:
                s.timestep *= 0.95

    for j, p in enumerate(params):
        p.timestep = samplers[j].timestep
        
for s in samplers:
    s.process.terminate()

for x in algorithm.tgs:
    for y in x:
        y.process.terminate()
